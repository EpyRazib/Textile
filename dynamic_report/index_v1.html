                    "Fabric Composition": "Poly-Cotton Blend",
                    "Fabric Delivery End Date": "2025-09-20",
                    "Fabric Delivery Start Date": "2025-08-30",
                    "Fabric Color": "Olive Green",
                    "General Notes": "Lightweight fabric",
                    "Go for YD": "Yes",
                    "Grey Wasteage (%)": 3,
                    "GSM": 150,
                    "Knitting End Date": "2025-08-15",
                    "Knitting Start Date": "2025-08-01",
                    "Lot Physical": "LOT-PHY-004",
                    "Manufacturing Process": "Flat Knitting",
                    "Merchandiser": "Ms. Nusrat",
                    "Merchandising Team": "Team D",
                    "Net Yarn Req Qty.": 1250,
                    "Notes": "Use anti-pilling yarn",
                    "Previous Allocation Date": "2025-06-10",
                    "Textile Projection No.": "TP2025-004",
                    "Ref. Spinner": "Nice Spinning Ltd.",
                    "Revision Reason": "New forecast",
                    "Spinner Physical": "SPIN-PHY-004",
                    "Supplier Name": "Nice Spinning Ltd.",
                    "TNA Calender": "TNA-2025-Oct",
                    "Unit Name": "Unit-4",
                    "Yarn Booking Date (FR)": "2025-06-08",
                    "Yarn Booking Status": "In Progress",
                    "Yarn Certification": "BCI",
                    "Yarn PI": "PI2025-792",
                    "Allocation Remarks": "Quality Check Required",
                    "Allocation Status": "Pending",
                    "Booking By": "Mr. Faisal",
                    "Booking Status: Running/Close": "Running"
                }
            ];

            const fieldConfig = {
                "Allocated Qty.": { label: "Allocated Qty.", type: "number" },
                "Allocation Date": { label: "Allocation Date", type: "date" },
                "Allocation No.": { label: "Allocation No.", type: "text" },
                "Booking Date & Time": { label: "Booking Date & Time", type: "date" },
                "Booking Qty.": { label: "Booking Qty.", type: "number" },
                "Buyer Department": { label: "Buyer Department", type: "text", options: [...new Set(sampleData.map(item => item["Buyer Department"]))] },
                "Buyer Name": { label: "Buyer Name", type: "text", options: [...new Set(sampleData.map(item => item["Buyer Name"]))] },
                "Buyer Season Name": { label: "Buyer Season Name", type: "text" },
                "Fabric Construction": { label: "Fabric Construction", type: "text" },
                "Count": { label: "Count", type: "text" },
                "EWO No.": { label: "EWO No.", type: "text" },
                "Fabric Booking Date (FR)": { label: "Fabric Booking Date (FR)", type: "date" },
                "Fabric Booking No.": { label: "Fabric Booking No.", type: "text" },
                "Yarn Description": { label: "Yarn Description", type: "text" },
                "Yarn Projection No.": { label: "Yarn Projection No.", type: "text" },
                "Yarn Projection Date": { label: "Yarn Projection Date", type: "date" },
                "Yarn Required Date (FR)": { label: "Yarn Required Date (FR)", type: "date" },
                "Yarn Requirement Date": { label: "Yarn Requirement Date", type: "date" },
                "Yarn Sourcing Mode": { label: "Yarn Sourcing Mode", type: "text", options: [...new Set(sampleData.map(item => item["Yarn Sourcing Mode"]))] },
                "Yarn Composition": { label: "Yarn Composition", type: "text" },
                "Fabric Composition": { label: "Fabric Composition", type: "text" },
                "Fabric Delivery End Date": { label: "Fabric Delivery End Date", type: "date" },
                "Fabric Delivery Start Date": { label: "Fabric Delivery Start Date", type: "date" },
                "Fabric Color": { label: "Fabric Color", type: "text" },
                "General Notes": { label: "General Notes", type: "text" },
                "Go for YD": { label: "Go for YD", type: "text" },
                "Grey Wasteage (%)": { label: "Grey Wasteage (%)", type: "number" },
                "GSM": { label: "GSM", type: "number" },
                "Knitting End Date": { label: "Knitting End Date", type: "date" },
                "Knitting Start Date": { label: "Knitting Start Date", type: "date" },
                "Lot Physical": { label: "Lot Physical", type: "text" },
                "Manufacturing Process": { label: "Manufacturing Process", type: "text" },
                "Merchandiser": { label: "Merchandiser", type: "text", options: [...new Set(sampleData.map(item => item["Merchandiser"]))] },
                "Merchandising Team": { label: "Merchandising Team", type: "text" },
                "Net Yarn Req Qty.": { label: "Net Yarn Req Qty.", type: "number" },
                "Notes": { label: "Notes", type: "text" },
                "Previous Allocation Date": { label: "Previous Allocation Date", type: "date" },
                "Textile Projection No.": { label: "Textile Projection No.", type: "text" },
                "Ref. Spinner": { label: "Ref. Spinner", type: "text", options: [...new Set(sampleData.map(item => item["Ref. Spinner"]))] },
                "Revision Reason": { label: "Revision Reason", type: "text" },
                "Spinner Physical": { label: "Spinner Physical", type: "text" },
                "Supplier Name": { label: "Supplier Name", type: "text", options: [...new Set(sampleData.map(item => item["Supplier Name"]))] },
                "TNA Calender": { label: "TNA Calender", type: "text" },
                "Unit Name": { label: "Unit Name", type: "text", options: [...new Set(sampleData.map(item => item["Unit Name"]))] },
                "Yarn Booking Date (FR)": { label: "Yarn Booking Date (FR)", type: "date" },
                "Yarn Booking Status": { label: "Yarn Booking Status", type: "text", options: [...new Set(sampleData.map(item => item["Yarn Booking Status"]))] },
                "Yarn Certification": { label: "Yarn Certification", type: "text" },
                "Yarn PI": { label: "Yarn PI", type: "text" },
                "Allocation Remarks": { label: "Allocation Remarks", type: "text" },
                "Allocation Status": { label: "Allocation Status", type: "text", options: [...new Set(sampleData.map(item => item["Allocation Status"]))] },
                "Booking By": { label: "Booking By", type: "text", options: [...new Set(sampleData.map(item => item["Booking By"]))] },
                "Booking Status: Running/Close": { label: "Booking Status: Running/Close", type: "text", options: [...new Set(sampleData.map(item => item["Booking Status: Running/Close"]))] }
            };

            const fieldCategories = {
                "Date Fields": [
                    "Allocation Date",
                    "Booking Date & Time",
                    "Fabric Booking Date (FR)",
                    "Yarn Projection Date",
                    "Yarn Required Date (FR)",
                    "Yarn Requirement Date",
                    "Fabric Delivery End Date",
                    "Fabric Delivery Start Date",
                    "Knitting End Date",
                    "Knitting Start Date",
                    "Previous Allocation Date",
                    "Yarn Booking Date (FR)"
                ],
                "Quantity Fields": [
                    "Allocated Qty.",
                    "Booking Qty.",
                    "Net Yarn Req Qty."
                ],
                "Number Fields": [
                    "Allocation No.",
                    "EWO No.",
                    "Fabric Booking No.",
                    "Yarn Projection No.",
                    "Yarn PI"
                ],
                "Text Fields": [
                    "Fabric Composition",
                    "Fabric Color",
                    "General Notes",
                    "Go for YD",
                    "Lot Physical",
                    "Manufacturing Process",
                    "Merchandiser",
                    "Merchandising Team",
                    "Notes",
                    "Ref. Spinner",
                    "Revision Reason",
                    "Spinner Physical",
                    "Supplier Name",
                    "TNA Calender",
                    "Unit Name",
                    "Yarn Booking Status",
                    "Yarn Certification",
                    "Allocation Remarks",
                    "Allocation Status",
                    "Booking By",
                    "Booking Status: Running/Close"
                ],
                "Other Fields": [
                    "Buyer Department",
                    "Buyer Name",
                    "Buyer Season Name",
                    "Fabric Construction",
                    "Count",
                    "Yarn Description",
                    "Yarn Sourcing Mode",
                    "Yarn Composition",
                    "Grey Wasteage (%)",
                    "GSM",
                    "Textile Projection No."
                ]
            };

            const App = () => {
                const [criteriaFields, setCriteriaFields] = useState([]);
                const [reportFields, setReportFields] = useState([]);
                const [filters, setFilters] = useState({});
                const [reportData, setReportData] = useState([]);
                const [searchTerm, setSearchTerm] = useState("");
                const [selectedFields, setSelectedFields] = useState({});
                const [columnFilters, setColumnFilters] = useState({});
                const [sortConfig, setSortConfig] = useState({});
                const [groupByFields, setGroupByFields] = useState([]);
                const [showGroupBy, setShowGroupBy] = useState(false);
                const [currentPage, setCurrentPage] = useState(1);
                const itemsPerPage = 10;
                const criteriaDropRef = useRef(null);
                const reportDropRef = useRef(null);
                const groupByDropRef = useRef(null);
                const [draggingHeader, setDraggingHeader] = useState(null);

                const generateReport = useCallback(() => {
                    let filteredData = [...sampleData];

                    // Apply global filters
                    Object.keys(filters).forEach(field => {
                        const filter = filters[field];
                        const fieldType = fieldConfig[field].type;

                        filteredData = filteredData.filter(item => {
                            if (fieldType === 'text') {
                                return !filter || filter === '' || item[field] === filter;
                            } else if (fieldType === 'number') {
                                const [min, max] = filter || [0, Infinity];
                                return item[field] >= min && item[field] <= max;
                            } else if (fieldType === 'date') {
                                const [start, end] = filter || ['', ''];
                                const itemDate = new Date(item[field]);
                                const startDate = start ? new Date(start) : new Date(-8640000000000000);
                                const endDate = end ? new Date(end) : new Date(8640000000000000);
                                return itemDate >= startDate && itemDate <= endDate;
                            }
                            return true;
                        });
                    });

                    // Apply column filters
                    Object.keys(columnFilters).forEach(field => {
                        const filterValue = columnFilters[field].toLowerCase();
                        if (filterValue) {
                            filteredData = filteredData.filter(item =>
                                String(item[field]).toLowerCase().includes(filterValue)
                            );
                        }
                    });

                    // Apply sorting
                    if (sortConfig.field) {
                        filteredData.sort((a, b) => {
                            if (a[sortConfig.field] < b[sortConfig.field]) {
                                return sortConfig.direction === 'asc' ? -1 : 1;
                            }
                            if (a[sortConfig.field] > b[sortConfig.field]) {
                                return sortConfig.direction === 'asc' ? 1 : -1;
                            }
                            return 0;
                        });
                    }

                    // Group by multiple fields and calculate subtotals
                    let groupedData = [];
                    if (groupByFields.length > 0) {
                        const groups = {};
                        filteredData.forEach(item => {
                            const groupKey = groupByFields.map(field => `${field}: ${item[field]}`).join(' | ');
                            if (!groups[groupKey]) {
                                groups[groupKey] = [];
                            }
                            groups[groupKey].push(item);
                        });

                        Object.keys(groups).forEach(groupKey => {
                            const groupItems = groups[groupKey];
                            groupedData.push(...groupItems);

                            const subtotal = { isSubtotal: true };
                            groupByFields.forEach(field => {
                                subtotal[field] = groupKey.split(' | ').find(part => part.startsWith(`${field}:`))?.split(': ')[1] || '';
                            });
                            ['Allocated Qty.', 'Booking Qty.', 'Net Yarn Req Qty.'].forEach(field => {
                                if (reportFields.includes(field)) {
                                    subtotal[field] = groupItems.reduce((sum, item) => sum + (item[field] || 0), 0);
                                }
                            });
                            groupedData.push(subtotal);
                        });
                    } else {
                        groupedData = filteredData;
                    }

                    const selectedFieldsList = reportFields.length > 0 ? reportFields : Object.keys(fieldConfig);
                    const mappedData = groupedData.map(item => {
                        const row = {};
                        selectedFieldsList.forEach(field => {
                            row[field] = item[field];
                        });
                        return row;
                    });

                    setReportData(mappedData);
                }, [filters, columnFilters, sortConfig, groupByFields, reportFields]);

                useEffect(() => {
                    generateReport();
                }, [generateReport]);

                const handleDragStart = (e, field) => {
                    e.dataTransfer.setData("text/plain", field);
                    setDraggingHeader(field);
                };

                const handleCriteriaDrop = (e) => {
                    e.preventDefault();
                    const field = e.dataTransfer.getData("text/plain");
                    if (field && !criteriaFields.includes(field)) {
                        setCriteriaFields(prev => [...prev, field]);
                    }
                };

                const handleReportDrop = (e) => {
                    e.preventDefault();
                    const field = e.dataTransfer.getData("text/plain");
                    if (field && !reportFields.includes(field)) {
                        setReportFields(prev => [...prev, field]);
                    }
                };

                const handleGroupByDrop = (e) => {
                    e.preventDefault();
                    const field = e.dataTransfer.getData("text/plain");
                    if (field && !groupByFields.includes(field) && (fieldConfig[field].type === 'text' || fieldConfig[field].type === 'date')) {
                        setGroupByFields(prev => [...prev, field]);
                    }
                };

                const removeGroupByField = (field) => {
                    setGroupByFields(groupByFields.filter(f => f !== field));
                };

                const allowDrop = (e) => {
                    e.preventDefault();
                };

                const handleCheckboxChange = (field) => {
                    setSelectedFields(prev => {
                        const isSelected = !prev[field];
                        if (isSelected && !reportFields.includes(field)) {
                            setReportFields(prev => [...prev, field]);
                        } else if (!isSelected && reportFields.includes(field)) {
                            setReportFields(prev => prev.filter(f => f !== field));
                        }
                        return { ...prev, [field]: isSelected };
                    });
                };

                const removeCriteriaField = (field) => {
                    setCriteriaFields(criteriaFields.filter(f => f !== field));
                    setFilters(prev => {
                        const newFilters = { ...prev };
                        delete newFilters[field];
                        return newFilters;
                    });
                };

                const removeReportField = (field) => {
                    setReportFields(reportFields.filter(f => f !== field));
                    setSelectedFields(prev => {
                        const newSelected = { ...prev };
                        delete newSelected[field];
                        return newSelected;
                    });
                };

                const handleFilterChange = (field, value) => {
                    setFilters(prev => ({ ...prev, [field]: value }));
                };

                const exportToExcel = () => {
                    if (window.XLSX && XLSX.utils && XLSX.writeFile) {
                        const ws = XLSX.utils.json_to_sheet(reportData);
                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, "Report");
                        XLSX.writeFile(wb, "report.xlsx");
                    } else {
                        alert("Excel export failed. Please ensure all libraries are loaded.");
                    }
                };

                const exportToPDF = () => {
                    if (window.jspdf && window.jspdf.jsPDF && window.jspdf.jsPDF.prototype.autoTable) {
                        const doc = new jsPDF();
                        doc.setFontSize(12);
                        doc.text("Report", 10, 10);

                        const headers = reportFields.length > 0 ? reportFields : Object.keys(fieldConfig);
                        const tableData = reportData.map(row => headers.map(field => row[field] !== undefined ? String(row[field]) : ''));

                        doc.autoTable({
                            head: [headers.map(field => fieldConfig[field].label)],
                            body: tableData,
                            startY: 20,
                        });

                        doc.save("report.pdf");
                    } else {
                        alert("PDF export failed. Please ensure all libraries are loaded.");
                    }
                };

                const renderFilterInput = (field) => {
                    const config = fieldConfig[field];
                    if (config.type === 'text') {
                        return (
                            <select
                                className="border rounded p-1 w-48"
                                onChange={(e) => handleFilterChange(field, e.target.value)}
                                aria-label={`Filter ${config.label}`}
                            >
                                <option value="">Select {config.label}</option>
                                {config.options?.map(option => (
                                    <option key={option} value={option}>{option}</option>
                                ))}
                            </select>
                        );
                    } else if (config.type === 'number') {
                        return (
                            <div className="flex space-x-2">
                                <input
                                    type="number"
                                    placeholder="Min"
                                    className="border rounded p-1 w-20"
                                    onChange={(e) => handleFilterChange(field, [
                                        e.target.value ? Number(e.target.value) : 0,
                                        filters[field]?.[1] || Infinity
                                    ])}
                                    aria-label={`Minimum ${config.label}`}
                                />
                                <input
                                    type="number"
                                    placeholder="Max"
                                    className="border rounded p-1 w-20"
                                    onChange={(e) => handleFilterChange(field, [
                                        filters[field]?.[0] || 0,
                                        e.target.value ? Number(e.target.value) : Infinity
                                    ])}
                                    aria-label={`Maximum ${config.label}`}
                                />
                            </div>
                        );
                    } else if (config.type === 'date') {
                        return (
                            <div className="flex space-x-2">
                                <input
                                    type="date"
                                    className="border rounded p-1"
                                    onChange={(e) => handleFilterChange(field, [
                                        e.target.value,
                                        filters[field]?.[1] || ''
                                    ])}
                                    aria-label={`Start date for ${config.label}`}
                                />
                                <input
                                    type="date"
                                    className="border rounded p-1"
                                    onChange={(e) => handleFilterChange(field, [
                                        filters[field]?.[0] || '',
                                        e.target.value
                                    ])}
                                    aria-label={`End date for ${config.label}`}
                                />
                            </div>
                        );
                    }
                    return null;
                };

                const filterFields = (fields) => {
                    if (!searchTerm) return fields;
                    return fields.filter(field =>
                        field.toLowerCase().includes(searchTerm.toLowerCase())
                    );
                };

                const handleHeaderDragStart = (e, field) => {
                    e.dataTransfer.setData("text/plain", field);
                    setDraggingHeader(field);
                };

                const handleHeaderDragOver = (e) => {
                    e.preventDefault();
                    const target = e.target.closest('th');
                    if (target && draggingHeader && draggingHeader !== target.getAttribute('data-field')) {
                        target.classList.add('drag-over');
                    }
                };

                const handleHeaderDrop = (e, targetField) => {
                    e.preventDefault();
                    const target = e.target.closest('th');
                    if (target && draggingHeader && target.getAttribute('data-field') !== draggingHeader) {
                        const sourceIndex = reportFields.indexOf(draggingHeader);
                        const targetIndex = reportFields.indexOf(target.getAttribute('data-field'));
                        if (sourceIndex !== -1 && targetIndex !== -1) {
                            const newReportFields = [...reportFields];
                            newReportFields.splice(sourceIndex, 1);
                            newReportFields.splice(targetIndex, 0, draggingHeader);
                            setReportFields(newReportFields);
                        }
                    }
                    document.querySelectorAll('.draggable-header').forEach(header => header.classList.remove('drag-over'));
                    setDraggingHeader(null);
                };

                const handleDragEnd = () => {
                    document.querySelectorAll('.draggable-header').forEach(header => header.classList.remove('drag-over'));
                    setDraggingHeader(null);
                };

                const handleColumnFilterChange = (field, value) => {
                    setColumnFilters(prev => ({ ...prev, [field]: value }));
                };

                const handleSort = (field) => {
                    setSortConfig(prev => ({
                        field,
                        direction: prev.field === field && prev.direction === 'asc' ? 'desc' : 'asc'
                    }));
                };

                const getTotalForQuantity = (field) => {
                    return reportData.reduce((sum, row) => sum + (row[field] || 0), 0);
                };

                const handleKeyDown = (e, field) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        handleCheckboxChange(field);
                    }
                };

                const paginatedData = reportData.slice(
                    (currentPage - 1) * itemsPerPage,
                    currentPage * itemsPerPage
                );

                return (
                    <div className="max-w-6xl mx-auto flex">
                        <div className="w-1/4 bg-gray-100 p-4 rounded-lg mr-4">
                            <h2 className="text-lg font-semibold mb-2">Available Fields</h2>
                            <input
                                type="file"
                                accept=".xlsx, .xls"
                                className="mb-4"
                                onChange={(e) => {
                                    const file = e.target.files[0];
                                    if (file) {
                                        const reader = new FileReader();
                                        reader.onload = (event) => {
                                            gk_isXlsx = true;
                                            gk_xlsxFileLookup[file.name] = true;
                                            gk_fileData[file.name] = event.target.result.split(',')[1];
                                            const csvData = loadFileData(file.name);
                                            console.log("Loaded CSV:", csvData);
                                            // Optionally parse csvData to update sampleData
                                        };
                                        reader.readAsDataURL(file);
                                    }
                                }}
                                aria-label="Upload Excel file"
                            />
                            <input
                                type="text"
                                placeholder="Search fields..."
                                className="border rounded p-2 mb-4 w-full"
                                value={searchTerm}
                                onChange={(e) => setSearchTerm(e.target.value)}
                                aria-label="Search fields"
                            />
                            {Object.entries(fieldCategories).map(([category, fields]) => (
                                <div key={category} className="mb-4">
                                    <details className="bg-white p-2 rounded shadow">
                                        <summary className="font-semibold cursor-pointer">
                                            {category} ({filterFields(fields).length})
                                        </summary>
                                        <div className="mt-2 flex flex-col gap-2">
                                            {filterFields(fields).map(field => (
                                                <div
                                                    key={field}
                                                    draggable="true"
                                                    onDragStart={(e) => handleDragStart(e, field)}
                                                    onKeyDown={(e) => handleKeyDown(e, field)}
                                                    tabIndex={0}
                                                    className={`draggable-field ${selectedFields[field] ? 'checked' : ''}`}
                                                    role="button"
                                                    aria-label={`Select ${field}`}
                                                >
                                                    <input
                                                        type="checkbox"
                                                        checked={selectedFields[field] || false}
                                                        onChange={() => handleCheckboxChange(field)}
                                                        aria-label={`Toggle ${field}`}
                                                    />
                                                    {field}
                                                </div>
                                            ))}
                                        </div>
                                    </details>
                                </div>
                            ))}
                        </div>
                        <div className="w-3/4">
                            <h1 className="text-2xl font-bold mb-4">Dynamic Report Generator</h1>
                            <div
                                ref={criteriaDropRef}
                                onDrop={handleCriteriaDrop}
                                onDragOver={allowDrop}
                                className="drop-area"
                            >
                                <h2 className="text-lg font-semibold mb-2">Criteria Fields</h2>
                                {criteriaFields.length === 0 && (
                                    <p className="text-gray-500">Drag and drop fields here</p>
                                )}
                                {criteriaFields.map(field => (
                                    <div key={field} className="flex items-center space-x-2 mb-2">
                                        <span className="w-24">{fieldConfig[field].label}:</span>
                                        {renderFilterInput(field)}
                                        <button
                                            className="text-red-500 text-sm"
                                            onClick={() => removeCriteriaField(field)}
                                            aria-label={`Remove ${fieldConfig[field].label}`}
                                        >
                                            Remove
                                        </button>
                                    </div>
                                ))}
                            </div>
                            <div
                                ref={reportDropRef}
                                onDrop={handleReportDrop}
                                onDragOver={allowDrop}
                                className="drop-area"
                            >
                                <h2 className="text-lg font-semibold mb-2">Report Fields</h2>
                                {reportFields.length === 0 && (
                                    <p className="text-gray-500">Drag and drop fields here</p>
                                )}
                                <div className="flex flex-wrap gap-2">
                                    {reportFields.map(field => (
                                        <div key={field} className="flex items-center space-x-2">
                                            <span>{fieldConfig[field].label}</span>
                                            <button
                                                className="text-red-500 text-sm"
                                                onClick={() => removeReportField(field)}
                                                aria-label={`Remove ${fieldConfig[field].label}`}
                                            >
                                                Remove
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div
                                ref={groupByDropRef}
                                onDrop={handleGroupByDrop}
                                onDragOver={allowDrop}
                                className={`group-by-area ${showGroupBy ? 'active' : ''}`}
                            >
                                <h2 className="text-lg font-semibold mb-2">Group By Fields</h2>
                                {groupByFields.length === 0 && (
                                    <p className="text-gray-500">Drag and drop fields here to group by (Text/Date fields only)</p>
                                )}
                                <div className="flex flex-wrap gap-2">
                                    {groupByFields.map(field => (
                                        <div key={field} className="flex items-center space-x-2 bg-blue-200 p-1 rounded">
                                            <span>{fieldConfig[field].label}</span>
                                            <button
                                                className="text-red-500 text-sm"
                                                onClick={() => removeGroupByField(field)}
                                                aria-label={`Remove ${fieldConfig[field].label} from group by`}
                                            >
                                                Remove
                                            </button>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            <div className="mb-4">
                                <label className="flex items-center">
                                    <input
                                        type="checkbox"
                                        checked={showGroupBy}
                                        onChange={(e) => setShowGroupBy(e.target.checked)}
                                        aria-label="Show group by fields"
                                    />
                                    <span className="ml-2">Show Group By</span>
                                </label>
                            </div>
                            <button
                                className="bg-purple-500 text-white px-6 py-2 rounded mb-6"
                                onClick={generateReport}
                                aria-label="Generate report"
                            >
                                Generate Report
                            </button>
                            {reportData.length > 0 && (
                                <div>
                                    <div className="mb-4 flex justify-start">
                                        <button
                                            className="bg-blue-500 text-white px-4 py-2 rounded mr-2"
                                            onClick={exportToExcel}
                                            aria-label="Export to Excel"
                                        >
                                            Export to Excel
                                        </button>
                                        <button
                                            className="bg-blue-500 text-white px-4 py-2 rounded"
                                            onClick={exportToPDF}
                                            aria-label="Export to PDF"
                                        >
                                            Export to PDF
                                        </button>
                                    </div>
                                    <table className="w-full border-collapse border border-gray-300">
                                        <thead>
                                            <tr className="bg-gray-200">
                                                {(reportFields.length > 0 ? reportFields : Object.keys(fieldConfig)).map((field) => (
                                                    <th
                                                        key={field}
                                                        className="draggable-header"
                                                        data-field={field}
                                                        draggable="true"
                                                        onDragStart={(e) => handleHeaderDragStart(e, field)}
                                                        onDragOver={handleHeaderDragOver}
                                                        onDrop={(e) => handleHeaderDrop(e, field)}
                                                        onDragEnd={handleDragEnd}
                                                        aria-label={`Column header for ${fieldConfig[field].label}`}
                                                    >
                                                        <div className="header-content">
                                                            <span>{fieldConfig[field].label}</span>
                                                            <div className="filter-sort-group">
                                                                <input
                                                                    type="text"
                                                                    className="filter-input"
                                                                    placeholder="Filter..."
                                                                    value={columnFilters[field] || ''}
                                                                    onChange={(e) => handleColumnFilterChange(field, e.target.value)}
                                                                    aria-label={`Filter ${fieldConfig[field].label}`}
                                                                />
                                                                <span
                                                                    className="sort-icon"
                                                                    onClick={() => handleSort(field)}
                                                                    role="button"
                                                                    aria-label={`Sort ${fieldConfig[field].label} ${sortConfig.field === field && sortConfig.direction === 'asc' ? 'descending' : 'ascending'}`}
                                                                >
                                                                    {sortConfig.field === field ? (
                                                                        sortConfig.direction === 'asc' ? ' ↑' : ' ↓'
                                                                    ) : ' ↕'}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    </th>
                                                ))}
                                            </tr>
                                        </thead>
                                        <tbody>
                                            {paginatedData.map((row, index) => (
                                                <tr key={index} className={row.isSubtotal ? 'subtotal-row' : ''}>
                                                    {(reportFields.length > 0 ? reportFields : Object.keys(fieldConfig)).map(field => (
                                                        <td key={field} className="border border-gray-300 p-2">
                                                            {row[field] !== undefined ? String(row[field]) : ''}
                                                        </td>
                                                    ))}
                                                </tr>
                                            ))}
                                            <tr className="total-row">
                                                {(reportFields.length > 0 ? reportFields : Object.keys(fieldConfig)).map(field => (
                                                    <td key={field} className="border border-gray-300 p-2">
                                                        {['Allocated Qty.', 'Booking Qty.', 'Net Yarn Req Qty.'].includes(field) ? getTotalForQuantity(field) : ''}
                                                    </td>
                                                ))}
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div className="flex justify-between mt-4">
                                        <button
                                            onClick={() => setCurrentPage(prev => Math.max(prev - 1, 1))}
                                            disabled={currentPage === 1}
                                            className="bg-gray-300 px-4 py-2 rounded disabled:opacity-50"
                                            aria-label="Previous page"
                                        >
                                            Previous
                                        </button>
                                        <span aria-label={`Current page ${currentPage} of ${Math.ceil(reportData.length / itemsPerPage)}`}>
                                            Page {currentPage} of {Math.ceil(reportData.length / itemsPerPage)}
                                        </span>
                                        <button
                                            onClick={() => setCurrentPage(prev => prev + 1)}
                                            disabled={currentPage === Math.ceil(reportData.length / itemsPerPage)}
                                            className="bg-gray-300 px-4 py-2 rounded disabled:opacity-50"
                                            aria-label="Next page"
                                        >
                                            Next
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                );
            };

            ReactDOM.render(<App />, document.getElementById('root'));
        } catch (e) {
            console.error('Error rendering application:', e);
            document.getElementById('root').innerHTML = '<h1 class="text-red-500 text-center">Error loading application. Please check console for details.</h1>';
        }
    </script>
</body>
</html>
